#include <iostream>
#include <fstream>
#include <TFile.h>
#include <TApplication.h>
#include <TCanvas.h>
#include <TPaveStats.h>
#include <TH1.h>
#include <TH2.h>
#include <TLegend.h>
#include <TMath.h>
#include <TRandom3.h>

#include "G4data.h"


bool vetoON = true;
float hitThreshold = 10;
float trigThreshold = 300;
float upperD = 2500;
float nPhE_keV[61];   // number of photo-electrons per keV per unit
float nADC_PhE[61];   // number of ADC channels per photo-electrons per unit
TH1F *Sn, *SnR0, *SnR1, *SnR2;
TH1F *S1, *S1R0, *S1R1, *S1R2;
TH1F *S2, *S2R0, *S2R1, *S2R2;
TH1F *S3, *S3R0, *S3R1, *S3R2;
TH1F *Dn, *D1, *D2T, *D2P, *D2C;
TH1F *Z20, *Z21, *EM;

void ReadCalibrationParameters()
{
  std::ifstream lightyield("FastSci_LightYields.dat");
  std::ifstream pmtgain("PMT_gains.dat");

  for (int x = 0; x < 61; x++) {
    lightyield >> nPhE_keV[x];
    pmtgain >> nADC_PhE[x];
  }

  lightyield.close();
  pmtgain.close();

}

void SumEnergiesByUnits(Det_event* unit)
{
  int index[61];
  int n = -1;
  for (int x = 0; x < 61; x++) index[x] = -1;

  for (int x = 0; x < unit->nhits; x++) {
    int UnitId = unit->UnitId[x];
    float E = unit->Edep[x];
    if (E > 0) {
      if (index[UnitId] == -1) { // new PDC unit
	index[UnitId] = ++n;
	unit->Edep[n] = E;
	unit->UnitId[n] = UnitId;
      }
      else unit->Edep[index[UnitId]] += E;
    }
  }
  unit->nhits = n+1; // update nhits with number of units with a hit
}

void EnergyConversion_keV2ADC(G4data* G4)
{
  TRandom3 random(0); // "TRandom3 is the best random engine in ROOT. 0 means seed from system clock."

  // ---------- slow scintillator ----------
  for (int x = 0; x < G4->slow->nhits; x++) {
    if (G4->slow->UnitId[x] == 8) G4->slow->Edep[x] = 0; // dead PDC nb 8
  }
  SumEnergiesByUnits(G4->slow);

  //std::cout << "nb hits " << G4->fast->nhits << std::endl;
  // ---------- fast scintillator ----------
  for (int x = 0; x < G4->fast->nhits; x++) {
    float E = G4->fast->Edep[x];
    if (G4->fast->UnitId[x] == 8) E = 0; // dead PDC nb 8
    if (E > 0) {
      // correction for scintillator non-linearity response
      E = E * (1.001 - 0.486 * exp(-0.0902 * E));
      // z position dependance
      E =  (1.0 - (G4->fast->Pz[x] - 357.5) * 0.0008) * E; //357.5 is the mean photoabsorption position

      // debug
      //std::cout<<"E "<<G4->fast->Edep[x]<<" PDC "<<G4->fast->UnitId[x]<<" position x y z "<<G4->fast->Px[x]<<" "<<G4->fast->Py[x]<<" "<<G4->fast->Pz[x]<<std::endl;

    }
    G4->fast->Edep[x] = E;
  }
  SumEnergiesByUnits(G4->fast);
  for (int x = 0; x < G4->fast->nhits; x++) {
    float E = G4->fast->Edep[x];
    if (E > 0) {
      // correction for PMT photon-electron production (low energy cutoff)
      int UnitId = G4->fast->UnitId[x];
      int nPhE = random.Poisson(E * nPhE_keV[UnitId]);
      // correction for PMT gain fluctuation
      int ADC = random.Gaus(nPhE, 0.35*sqrt(nPhE)) * nADC_PhE[UnitId];
      G4->fast->Edep[x] = ADC;
    }
  }


  // ---------- bottom BGO scintillator ----------
  for (int x = 0; x < G4->bottomBGO->nhits; x++) {
    if (G4->bottomBGO->UnitId[x] == 8) G4->bottomBGO->Edep[x] = 0; // dead PDC nb 8
  }
  SumEnergiesByUnits(G4->bottomBGO);

  // ---------- SAS ----------
  SumEnergiesByUnits(G4->SAS);
}

bool EventsSelection(G4data* G4)
{
  bool valid = false;
  // ---------- fast scintillator ----------
  for (int x = 0; x < G4->fast->nhits; x++) {
    // trigger threshold and upper discrimator
    if ((G4->fast->Edep[x] > trigThreshold) && (G4->fast->Edep[x] < upperD)) valid = true;
  }
  if (valid) {
    // ---------- fast scintillator ----------
    for (int x = 0; x < G4->fast->nhits; x++) {
      // hit threshold
      if (G4->fast->Edep[x] < hitThreshold) G4->fast->Edep[x] = 0;
    }
    // ---------- slow scintillator ----------
    for (int x = 0; x < G4->slow->nhits; x++) {
      // hit threshold
      if (G4->slow->Edep[x] < 10) G4->slow->Edep[x] = 0;
      // veto (do not use veto before energy correction of slow and bottom BGO ?)
      if ((vetoON) && (G4->slow->Edep[x] > 0)) valid = false;      // > 5keV: slow waveform # fast waveform ?
    }
    // ---------- bottom BGO scintillator ----------
    for (int x = 0; x < G4->bottomBGO->nhits; x++) {
      // hit threshold
      if (G4->bottomBGO->Edep[x] < 10) G4->bottomBGO->Edep[x] = 0;
      // veto (do not use veto before energy correction of slow and bottom BGO ?)
      if ((vetoON) && (G4->bottomBGO->Edep[x] > 0)) valid = false; // > 5keV: BGO waveform # fast waveform ?
    }
    // ---------- SAS ----------
    for (int x = 0; x < G4->SAS->nhits; x++) {
      // hit threshold
      if (G4->SAS->Edep[x] < 10) G4->SAS->Edep[x] = 0;
      // veto
      if ((vetoON) && (G4->SAS->Edep[x] > 0)) valid = false;
    }
  }

  // update the number of hitten units
  SumEnergiesByUnits(G4->slow);
  SumEnergiesByUnits(G4->fast);
  SumEnergiesByUnits(G4->bottomBGO);
  SumEnergiesByUnits(G4->SAS);

  return valid;
}

void EnergyReconstruction_ADC2keV(G4data* G4)
{
  // ---------- fast scintillator ----------
  for (int x = 0; x < G4->fast->nhits; x++) {
    int ADC = G4->fast->Edep[x];
    if (ADC > 0) {
      // ADC to keV
      int UnitId = G4->fast->UnitId[x];
      float E = ADC / nADC_PhE[UnitId] / nPhE_keV[UnitId];
      // correction for scintillator non-linearity response
      E = E / (1.001 - 0.486 * exp(-0.0902 * E)); // not exactly correct
      G4->fast->Edep[x] = E;
    }
  }
}

void createHistos()
{
  // event multiplicity histogram
  EM = new TH1F("EM", "Event multiplicity", 10, 0, 10);
  //EM = new TH1F("EM", "Event multiplicity involving Unit 9", 10, 0, 10);
  EM->GetXaxis()->SetTitle("Event multiplicity");
  EM->GetYaxis()->SetTitle("Events/s");
  EM->GetXaxis()->CenterTitle();
  EM->GetYaxis()->CenterTitle();

  // nhits spectrum
  //Sn = new TH1F("Snhits", "G4 spectrum, all hit events", 120, 0, 120);
  Sn = new TH1F("Snhits", "G4 spectrum, all hit events", 128, 0, 4960);
  //Sn->GetXaxis()->SetTitle("Energy (keV)");
  //Sn->GetXaxis()->SetTitle("Photo-electrons");
  Sn->GetXaxis()->SetTitle("ADC channel");
  Sn->GetYaxis()->SetTitle("Events/bin/s");
  Sn->GetXaxis()->CenterTitle();
  Sn->GetYaxis()->CenterTitle();
  SnR0 = (TH1F*)Sn->Clone("SnhitsRing0");
  SnR0->SetTitle("G4 spectrum ring 0, all hit events");
  SnR1 = (TH1F*)Sn->Clone("SnhitsRing1");
  SnR1->SetTitle("G4 spectrum ring 1, all hit events");
  SnR2 = (TH1F*)Sn->Clone("SnhitsRing2");
  SnR2->SetTitle("G4 spectrum ring 2, all hit events");
  // 1hit spectrum
  S1 = (TH1F*)Sn->Clone("S1hit");
  S1->SetTitle("G4 spectrum, 1 hit events");
  S1R0 = (TH1F*)Sn->Clone("S1hitsRing0");
  S1R0->SetTitle("G4 spectrum ring 0, 1 hit events");
  S1R1 = (TH1F*)Sn->Clone("S1hitsRing1");
  S1R1->SetTitle("G4 spectrum ring 1, 1 hit events");
  S1R2 = (TH1F*)Sn->Clone("S1hitsRing2");
  S1R2->SetTitle("G4 spectrum ring 2, 1 hit events");  
  // 2hits spectrum
  S2 = (TH1F*)Sn->Clone("S2hits");
  S2->SetTitle("G4 spectrum, 2 hit events");
  S2R0 = (TH1F*)Sn->Clone("S2hitsRing0");
  S2R0->SetTitle("G4 spectrum ring 0, 2 hit events");
  S2R1 = (TH1F*)Sn->Clone("S2hitsRing1");
  S2R1->SetTitle("G4 spectrum ring 1, 2 hit events");
  S2R2 = (TH1F*)Sn->Clone("S2hitsRing2");
  S2R2->SetTitle("G4 spectrum ring 2, 2 hit events");  
  // 3hits spectrum
  S3 = (TH1F*)Sn->Clone("S3hits");
  S3->SetTitle("G4 spectrum, 3 hit events");
  S3R0 = (TH1F*)Sn->Clone("S3hitsRing0");
  S3R0->SetTitle("G4 spectrum ring 0, 3 hit events");
  S3R1 = (TH1F*)Sn->Clone("S3hitsRing1");
  S3R1->SetTitle("G4 spectrum ring 1, 3 hit events");
  S3R2 = (TH1F*)Sn->Clone("S3hitsRing2");
  S3R2->SetTitle("G4 spectrum ring 2, 3 hit events");  

  // nhits distribution
  Dn = new TH1F("Dnhits", "G4 distribution, nhit events", 61, -0.5, 60.5);
  Dn->GetXaxis()->SetTitle("Detector id");
  Dn->GetYaxis()->SetTitle("Events/detector");
  Dn->GetXaxis()->CenterTitle();
  Dn->GetYaxis()->CenterTitle();
  // 1hit distribution
  D1 = (TH1F*)Dn->Clone("D1hit");
  D1->SetTitle("G4 distribution, 1hit events");
  // 2hits distribution
  D2T = (TH1F*)Dn->Clone("D2hitsTotal");
  D2T->SetTitle("G4 distribution, 2hit events");
  D2P = (TH1F*)D2T->Clone("D2hitsPhoto");
  D2C = (TH1F*)D2T->Clone("D2hitsCompton");

  // 2hits Z position
  Z20 = new TH1F("Z2hitsPhotoUnit0", "G4 z positions, 2hit events", 50, 200, 500);
  Z21 = (TH1F*)Z20->Clone("Z2hitsPhotoUnit1");

  // 2hits xy map
  //TH2F* Sc1 = new TH2F("Sc1", "largest vs second largest", 120, 0, 120, 120, 0, 120);

}

void fillnhits(G4data* G4)
{
  for (int x = 0; x < G4->fast->nhits; x++) {
    float E = G4->fast->Edep[x];
    int UnitId = G4->fast->UnitId[x];

    Sn->Fill(E);
    if (UnitId == 0) SnR0->Fill(E);
    if (UnitId == 1) SnR1->Fill(E);
    if (UnitId == 9) SnR2->Fill(E);

    // Distribution
    Dn->Fill(UnitId);
  }

  // veto check
  //for (int x = 0; x < G4->slow->nhits; x++) std::cout << "pipi" << std::endl;
  //for (int x = 0; x < G4->bottomBGO->nhits; x++) std::cout << "caca" << std::endl;
  //for (int x = 0; x < G4->SAS->nhits; x++) std::cout << "caca" << std::endl;


}

void fill1hit(G4data* G4)
{
  if (G4->fast->nhits == 1) {
    float E = G4->fast->Edep[0];
    int UnitId = G4->fast->UnitId[0];

    S1->Fill(E);
    if (UnitId == 0) S1R0->Fill(E);
    if (UnitId == 1) S1R1->Fill(E);
    if (UnitId == 9) S1R2->Fill(E);

    // Distribution
    D1->Fill(UnitId);
  }
}

void fill2hits(G4data* G4)
{
  if (G4->fast->nhits == 2) {
    for (int x = 0; x < 2; x++) {
      float E = G4->fast->Edep[x];
      int UnitId = G4->fast->UnitId[x];

      S2->Fill(E);
      if (UnitId == 0) S2R0->Fill(E);
      if (UnitId == 1) S2R1->Fill(E);
      if (UnitId == 9) S2R2->Fill(E);
    }

    // Distribution
    float E1 = G4->fast->Edep[0];
    float E2 = G4->fast->Edep[1];
    int UnitId1 = G4->fast->UnitId[0];
    int UnitId2 = G4->fast->UnitId[1];
      // Total energy
      D2T->Fill(UnitId1);
      D2T->Fill(UnitId2);
      // Photopeak
      if (E1 > E2) D2P->Fill(UnitId1);
      else D2P->Fill(UnitId2);
      // Compton
      if (E1 < E2) D2C->Fill(UnitId1);
      else D2C->Fill(UnitId2);

    // z positions
    if ((UnitId1 == 0) && (E1 > E2)) Z20->Fill(G4->fast->Pz[0]);
    if ((UnitId2 == 0) && (E2 > E1)) Z20->Fill(G4->fast->Pz[1]);
    if ((UnitId1 == 1) && (E1 > E2)) Z21->Fill(G4->fast->Pz[0]);
    if ((UnitId2 == 1) && (E2 > E1)) Z21->Fill(G4->fast->Pz[1]);

    // modulation curve

  }
}

void fill3hits(G4data* G4)
{
  if (G4->fast->nhits == 3) {
    for (int x = 0; x < 3; x++) {
      float E = G4->fast->Edep[x];
      int UnitId = G4->fast->UnitId[x];

      S3->Fill(E);
      if (UnitId == 0) S3R0->Fill(E);
      if (UnitId == 1) S3R1->Fill(E);
      if (UnitId == 9) S3R2->Fill(E);
    }
  }
}

void fillEventMult(G4data* G4)
{
  EM->Fill(G4->fast->nhits);
  // for (int x = 0; x < G4->fast->nhits; x++) {
  //  if (G4->fast->UnitId[x] == 9) EM->Fill(G4->fast->nhits);
  // }
}

void displayHistos()
{
  //gStyle->SetPalette(1);

  // print event multiplicity
  TCanvas* cEM = new TCanvas("G4eventMultiplicity","G4eventMultiplicity");
  cEM->SetGrid();
  EM->Scale(1./304.);
  EM->Draw("");
  // print nHits
  TCanvas* cSn = new TCanvas("G4spectrumNhits","G4spectrumNhits");
  cSn->SetGrid();
  cSn->SetLogy();
  Sn->Scale(1./304.);
  Sn->Draw("");
  SnR0->SetLineColor(kBlue);
  SnR0->Scale(1./304.);
  SnR0->Draw("sames");
  SnR1->SetLineColor(kRed);
  SnR1->Scale(1./304.);
  SnR1->Draw("sames");
  SnR2->SetLineColor(kGreen);
  SnR2->Scale(1./304.);
  SnR2->Draw("sames");
  TLegend* lSn = new TLegend(0.7, 0.6, 0.85, 0.75);
  lSn->AddEntry(Sn, "All units", "l");
  lSn->AddEntry(SnR0, "Ring 0 unit", "l");
  lSn->AddEntry(SnR1, "Ring 1 unit", "l");
  lSn->AddEntry(SnR2, "Ring 2 unit", "l");
  lSn->Draw();
  TCanvas* cDn = new TCanvas("G4distributionNhits","G4distributionNhits");
  cDn->SetGrid();
  cDn->SetLogy();
  Dn->Draw("histe");
  // print 1Hit
  TCanvas* cS1 = new TCanvas("G4spectrum1hit","G4spectrum1hit");
  cS1->SetGrid();
  cS1->SetLogy();
  S1->Scale(1./304.);
  S1->Draw("");
  S1R0->SetLineColor(kBlue);
  S1R0->Scale(1./304.);
  S1R0->Draw("sames");
  S1R1->SetLineColor(kRed);
  S1R1->Scale(1./304.);
  S1R1->Draw("sames");
  S1R2->SetLineColor(kGreen);
  S1R2->Scale(1./304.);
  S1R2->Draw("sames");
  TLegend* lS1 = new TLegend(0.7, 0.6, 0.85, 0.75);
  lS1->AddEntry(S1, "All units", "l");
  lS1->AddEntry(S1R0, "Ring 0 unit", "l");
  lS1->AddEntry(S1R1, "Ring 1 unit", "l");
  lS1->AddEntry(S1R2, "Ring 2 unit", "l");
  lS1->Draw();
  TCanvas* cD1 = new TCanvas("G4distribution1hit","G4distribution1hit");
  cD1->SetGrid();
  cD1->SetLogy();
  D1->Draw("histe");
  // print 2Hits
  TCanvas* cS2 = new TCanvas("G4spectrum2hits","G4spectrum2hits");
  cS2->SetGrid();
  cS2->SetLogy();
  S2->Scale(1./304.);
  S2->Draw("");
  S2R0->SetLineColor(kBlue);
  S2R0->Scale(1./304.);
  S2R0->Draw("sames");
  S2R1->SetLineColor(kRed);
  S2R1->Scale(1./304.);
  S2R1->Draw("sames");
  S2R2->SetLineColor(kGreen);
  S2R2->Scale(1./304.);
  S2R2->Draw("sames");
  TLegend* lS2 = new TLegend(0.7, 0.6, 0.85, 0.75);
  lS2->AddEntry(S2, "All units", "l");
  lS2->AddEntry(S2R0, "Ring 0 unit", "l");
  lS2->AddEntry(S2R1, "Ring 1 unit", "l");
  lS2->AddEntry(S2R2, "Ring 2 unit", "l");
  lS2->Draw();
  TCanvas* cD2 = new TCanvas("G4distribution2hits","G4distribution2hits");
  cD2->SetGrid();
  cD2->SetLogy();
  D2T->Draw("histe");
  D2P->SetLineColor(kGreen);
  D2P->Draw("sames");
  D2C->SetLineColor(kRed);
  D2C->Draw("sames");
  TLegend* lD2 = new TLegend(0.45, 0.6, 0.85, 0.75);
  lD2->AddEntry(D2T, "Total hits in fast scintillators", "l");
  lD2->AddEntry(D2P, "Photo hits (Emax) in fast scintillators", "l");
  lD2->AddEntry(D2C, "Compton hits (Emin) in fast scintillators", "l");
  lD2->Draw();
  TCanvas* cZ2 = new TCanvas("G4zpositions2hits","G4zpositions2hits");
  cZ2->SetGrid();
  Z20->Draw();
  gPad->Update(); //IMPORTANT
  TPaveStats *tps1 = (TPaveStats*) Z20->FindObject("stats");
  double X1 = tps1->GetX1NDC();
  double Y1 = tps1->GetY1NDC();
  double X2 = tps1->GetX2NDC();
  double Y2 = tps1->GetY2NDC();
  Z21->Draw();
  gPad->Update(); //IMPORTANT
  TPaveStats *tps2 = (TPaveStats*) Z21->FindObject("stats");
  tps2->SetTextColor(kRed);
  tps2->SetLineColor(kRed);
  tps2->SetX1NDC(X1);
  tps2->SetX2NDC(X2);
  tps2->SetY1NDC(Y1-(Y2-Y1));
  tps2->SetY2NDC(Y1);
  Z20->Draw("histe");
  Z21->SetLineColor(kRed);
  Z21->Draw("same");
  tps1->Draw("same");
  tps2->Draw("same");
  // print 3Hits
  TCanvas* cS3 = new TCanvas("G4spectrum3hits","G4spectrum3hits");
  cS3->SetGrid();
  cS3->SetLogy();
  S3->Scale(1./304.);
  S3->Draw("");
  S3R0->SetLineColor(kBlue);
  S3R0->Scale(1./304.);
  S3R0->Draw("sames");
  S3R1->SetLineColor(kRed);
  S3R1->Scale(1./304.);
  S3R1->Draw("sames");
  S3R2->SetLineColor(kGreen);
  S3R2->Scale(1./304.);
  S3R2->Draw("sames");
  TLegend* lS3 = new TLegend(0.7, 0.6, 0.85, 0.75);
  lS3->AddEntry(S3, "All units", "l");
  lS3->AddEntry(S3R0, "Ring 0 unit", "l");
  lS3->AddEntry(S3R1, "Ring 1 unit", "l");
  lS3->AddEntry(S3R2, "Ring 2 unit", "l");
  lS3->Draw();
}

int main(int argc, char* argv[])
{
  TApplication theApp("App", &argc, argv);

  // open the Tree and create objects to contain the branches
  TFile* f = new TFile("G4data.root","r");
  TTree* tree = (TTree*) f->Get("G4data");
  G4data* G4 = new G4data; //Declare the object
  G4->SetAddress(tree);    //Set every address explicitly (IMPORTANT!)

  // read the characteristics of the PDCs from ascii files
  ReadCalibrationParameters();

  // compute and print the angle matrix to a file
  //createAngleMatrix();

  // create histograms
  createHistos();

  // loop over all entries in the tree
  for (long i = 0; i < tree->GetEntries(); i++){
  //for (long i = 0; i < 50; i++){
    tree->GetEntry(i);

    if (G4->fast->EdepTot > 0) {
    //if (G4->fast->EdepTot == 59.5) {
      //std::cout << "Event nb " << i << std::endl;
      //std::cout << "G4->SAS->EdepTot " << G4->SAS->EdepTot << std::endl;

      // energy conversion: keV to ADC
      EnergyConversion_keV2ADC(G4);

      // events selection
      bool validEvent = EventsSelection(G4);

      if (validEvent) {
    	// energy reconstruction: ADC to keV
    	//EnergyReconstruction_ADC2keV(G4);

	// event multiplicity
	fillEventMult(G4);

    	// Nhits
    	fillnhits(G4);

    	// 1hit
      	fill1hit(G4);

    	// 2hits
    	fill2hits(G4);

   	// 3hits
    	fill3hits(G4);
      }
      //std::cout << std::endl;
    }
  }

  // display histograms
  displayHistos();

  theApp.Run();
  return 0;
}
